on load:
	MotdReload()
	load yaml "unlimited_adventures/AdventureCore/interface.yml" as "interface"
	if yaml value "server_name" of "interface" is not set:
		set yaml value "server_name" of "interface" to "<#6dd444>&lUnlimited Adventures"
	if yaml value "print_day_count" of "interface" is not set:
		set yaml value "print_day_count" of "interface" to true
	if yaml value "print_biome_name" of "interface" is not set:
		set yaml value "print_biome_name" of "interface" to true

	set {interface::server_name} to yaml value "server_name" of "interface"
	set {interface::print_day_count} to yaml value "print_day_count" of "interface"
	set {interface::print_biome_name} to yaml value "print_biome_name" of "interface"

	save yaml "interface"

every second:
	loop {players::*}:
		UpdateInterface(loop-value)
		DisplayInterface(loop-value)


function UpdateInterface(player: player):
	loop 4 times:
		set {_in_combat} to placeholder "combatlogx_in_combat" from {_player}
		set {_timer} to placeholder "combatlogx_time_left" from {_player}
		set {_location} to metadata value "location" of {_player}
		if world of {_player} is "dungeons":
			set {_floor} to GetPlayerFloor({_player})
			set {_dungeon_floor} to FindFloor({_floor})
			set {_dungeon_nr} to FindDungeon({_floor})
			set {_killed_monsters} to {dungeons::killed_monsters::%uuid of {_player}%}
			set {_required_kills} to {dungeons::config::dungeon_%{_dungeon_nr}%::%{_dungeon_floor}%::monster_kills_required}
			set {_bosses::*} to "miner_wrath" and "dracula" and "pharaoh"
			loop {_bosses::*}:
				set {_boss} to loop-value-2
				if {dungeons::loc::boss_spawn::%{_floor}%::%{_boss}%} is set:
					if {dungeons::loc::boss_spawn::%{_floor}%::%{_boss}%} is set:
						add {dungeons::config::dungeon_%{_dungeon_nr}%::%{_dungeon_floor}%::extra_kills_per_player}*size of GetPlayersInFloor({_floor}) to {_required_kills}
						set {_boss_floor} to true
						exit loop

			#	Dungeons Status
			if {_boss_floor} is true:
				if {dungeons::boss_alive::%{_floor}%::%{_boss}%} is true:
					set {_status} to "&e&lBOSS SPAWNED!"
				else:
					if difference between {dungeons::boss_death_date::%{_floor}%::%{_boss}%} and now >= {dungeons::config::boss::%{_boss}%::respawn_delay}:
						set {_status} to "&f‚ò† %{_killed_monsters}%/%{_required_kills}%"
					else:
						set {_status} to "&8‚ò† %{_killed_monsters}%/%{_required_kills}%"
			else:
				if {_killed_monsters} >= {_required_kills}:
					set {_status} to "&e&lNEXT FLOOR UNLOCKED!"
				else:
					set {_status} to "&f‚ò† %{_killed_monsters}%/%{_required_kills}%"

			set metadata value "ui_content_dungeons" of {_player} to "&f‚õè %{_location}%  %{_status}%"

		wait 0.25 second


function DisplayInterface(player: player):
	loop 20 times:
#		if {server::test_server} is true:
#			if difference between metadata value "display_visitor_count" of {_player} and now < 4 seconds:
#				set {_visitors} to placeholder "valiant_visitors_count" from {_player}
#				set metadata value "ui_content" of {_player} to "&f&lVisitors today: &e&l%{_visitors}%"
#		else:
		#	Combat Log

		if placeholder "floodgate_device" from {_player} is "win10":
			if metadata value "in_combat" of {_player} is true:
				set {_msg} to {combatlog::messages::ui_message}
				replace all "TIMER" with "%{_timer}%" in {_msg}
				set metadata value "ui_content" of {_player} to {_msg}
				set metadata value "in_combat" of {_player} to true
			else:
				#	Dungeons
				if world of {_player} is "dungeons":
					set metadata value "ui_content" of {_player} to metadata value "ui_content_dungeons" of {_player}
				
				# 	Spawn
				if world of {_player} is "spawn":
	#				if region of {_player} contains "spawn":
					if {premium_currency::%uuid of {_player}%} is set:
						set {_gems} to {premium_currency::%uuid of {_player}%}
					else:
						set {_gems} to 0
					set {_location} to metadata value "location" of {_player}
					set metadata value "ui_content" of {_player} to "&fÓêÅ %{_location}%  &fÓÑÅ %{colors::gold}%%floor({_player}'s money)%  &fÓÑÇ %{colors::gems}%%{_gems}%"

				#	Wilderness
				if world of {_player} is not "spawn" or "dungeons":
					set metadata value "ui_content" of {_player} to metadata value "compass" of {_player}

				set metadata value "in_combat" of {_player} to false
		else:
			if metadata value "in_combat" of {_player} is true:
				set {_msg} to {combatlog::messages::ui_message}
				replace all "TIMER" with "%{_timer}%" in {_msg}
				set metadata value "ui_content" of {_player} to {_msg}
				set metadata value "in_combat" of {_player} to true
			else:
				#	Dungeons
				if world of {_player} is "dungeons":
					set metadata value "ui_content" of {_player} to metadata value "ui_content_dungeons" of {_player}
				
				# 	Spawn
				if world of {_player} is "spawn":
	#				if region of {_player} contains "spawn":
					if {premium_currency::%uuid of {_player}%} is set:
						set {_gems} to {premium_currency::%uuid of {_player}%}
					else:
						set {_gems} to 0
					set {_location} to metadata value "location" of {_player}
					set metadata value "ui_content" of {_player} to "&fÓêÅ %{_location}%  &fÓÑÅ %{colors::gold}%%floor({_player}'s money)%  &fÓÑÇ %{colors::gems}%%{_gems}%"

				#	Wilderness
				if world of {_player} is not "spawn" or "dungeons":
					set metadata value "ui_content" of {_player} to metadata value "compass" of {_player}

				set metadata value "in_combat" of {_player} to false

		wait 1 tick


command /displayvisitorcount [<player>]:
	permission: admin
	trigger:
		set metadata value "display_visitor_count" of player-arg to now


at 6:01:
	if {interface::print_day_count} is true:
		loop {players::*}:
			PrintDayCount(loop-value)

function PrintDayCount(player: player):
	set metadata value "print_day_count_date" of {_player} to now
	set {_day} to round(({_player}'s time played / 20 minutes))
	set {_text} to "Day %{_day}%"
	loop length of {_text} times:
		set {_msg} to first loop-number characters of {_text}
		send action bar "%{_msg}%" to {_player}
		wait 3 tick
		play sound "entity.item.pickup" with volume 0.2 and pitch random number between 1.6 and 2 to {_player}
	wait 10 tick
	send action bar "- %{_msg}% -" to {_player}
	wait 10 tick
	send action bar "  %{_msg}%  " to {_player}
	wait 10 tick
	send action bar "- %{_msg}% -" to {_player}
	wait 10 tick
	send action bar "  %{_msg}%  " to {_player}


function PrintBiomeAnnouncement(player: player, text: string):
	if {interface::print_biome_name} is true:
		loop length of {_text} times:
			send title "" with subtitle first loop-number characters of {_text} to {_player} for 2 seconds with fadein 0 seconds
			wait 3 tick
			play sound "entity.item.pickup" with volume 0.12 and pitch random number between 1.6 and 2 to {_player}
	#		play sound "ui.button.click" with volume 0.2 and pitch random number between 1.8 and 2 to {_player}






#	Server MOTD

on server list ping:
	if {motd::enabled} is true:
		set {_text} to "%{motd::line::1}% %nl% %{motd::line::2}%"
		set the motd to {_text}

function MotdReload():
	load yaml "unlimited_adventures/AdventureCore/motd.yml" as "motd"

	if yaml value "motd_line.1" from "motd" is not set:
		wait 1 tick
		MotdCreateConfig()

	set {motd::enabled} to yaml value "enabled" from "motd"
	set {motd::line::1} to yaml value "motd_line.1" from "motd"
	set {motd::line::2} to yaml value "motd_line.2" from "motd"
	save yaml "motd"

function MotdCreateConfig():
	load yaml "unlimited_adventures/AdventureCore/motd.yml" as "motd"
	set yaml value "enabled" from "motd" to true
	set yaml value "motd_line.1" from "motd" to "            %placeholder "ui_server_name"% &f[¬ßx&a&c&e&6&7&31.21&f]"
	set yaml value "motd_line.2" from "motd" to "         ¬ßx&f&7&4&1&5&4‚ò† Dungeons ¬ßx&f&f&c&8&0&0ü™£ New Items ¬ßx&9&0&e&3&4&e‚≠ê New Mobs ¬ßx&f&7&4&1&5&4"
	save yaml "motd"

command /motdreload:
	permission: admin
	trigger:
		MotdReload()
		send "&fÓÑê &aServer MOTD reloaded!" to sender