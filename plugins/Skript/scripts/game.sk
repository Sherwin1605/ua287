on step on slime block:
	if "%regions at player%" contains "launch_pad":
		if difference between metadata value "launch_pad_cooldown" of player and now < 1 second:
			stop
		set metadata value "launch_pad_cooldown" of player to now
		play sound "minecraft:entity.player.attack.sweep" with volume 1 and pitch 1 at player
		push player upwards with speed 1.5
		wait 1 tick
		push player south with speed 5
		wait 1 tick
		push player south with speed 5
		loop 10 times:
			draw 3 cloud at location 1 meter above player with offset vector(0, 0, 0) with extra 0.1
			wait 1 ticks

#on right click:
#	if player's tool is a block:
#		if yaw of player > 50:
#			set {_loc} to location of player
#			add 1.6 to y coordinate of {_loc}
#			if distance between {_loc} and target block of player < 4:
#				stop
#			make player 
#			set block 1 meter in front of player to player's tool



on right click on item frame:
	stop
	if player is sneaking:
		cancel event
		if nbt of event-entity contains "Invisible:1b":
			send "1" to player
			add nbt from "{Invisible:0}" to nbt compound of event-entity
			stop
		else:
			send "2" to player
			add nbt from "{Invisible:1b}" to nbt compound of event-entity



command /sit:
	permission: core.sit
	trigger:
		Sit(player)

on right click on any stairs:
	if player is not sneaking:
		if player is not riding:
			Sit(player)

function Sit(player: player):
	if target block of {_player} is not any stairs:
		stop
	if distance between {_player} and target block of {_player} > 3:
		stop
	if difference between y coordinate of {_player} and y coordinate of target block of {_player} > 2:
		stop
	if pitch of {_player} < 60:
		stop
	set {_nbt} to empty nbt compound
	set {_custom} to compound tag "custom" of {_nbt}
	set string tag "sittable_arrow" of {_custom} to {_region}
	spawn arrow at location 0.4 meter below {_player}'s target block
	set {_arrow} to last spawned arrow
	make {_player} ride {_arrow}
	wait 1 tick
	set visibility of {_arrow} to false
	set gravity of {_arrow} to false
	hide {_arrow} from all players
	play sound "minecraft:block.stone.step" with volume 1 and pitch 1.5 at {_player}
#	play sound "minecraft:entity.player.attack.nodamage" with volume 1 and pitch 1 at {_player}

on dismount:
	if vehicle of the player is arrow:
		kill vehicle of the player
		loop all blocks in radius 0.6 of player:
			if loop-block is any stairs:
				push player up with speed 0.4
				if facing of loop-block is north:
					push player south with speed 0.6
				if facing of loop-block is south:
					push player north with speed 0.6
				if facing of loop-block is west:
					push player east with speed 0.6
				if facing of loop-block is east:
					push player west with speed 0.6
#				play sound "minecraft:block.stone.step" with volume 1 and pitch 2 at player
				play sound "minecraft:entity.player.attack.nodamage" with volume 1 and pitch 2 at player
				exit loop






function CropInteraction(player: player, block: block):
	set {_block_name} to "%type of {_block}%"
	if {_player} can build at location of {_block}:
		if age of {_block} is maximum age of {_block}:
			play sound "block.crop.break" with volume 1 and pitch random number between 0.8 and 1.2 at {_block}
			break {_block} naturally using {_player}'s tool

			if {_block_name} is "wheat item":
				if {_player} has wheat seed:
					set block at {_block} to wheat plant
					remove 1 wheat seed from {_player}
			if {_block_name} is "ripe potato plant":
				if {_player} has potato:
					set block at {_block} to potato plant
					remove 1 potato from {_player}
			if {_block_name} is "ripe carrot plant":
				if {_player} has carrot:
					set block at {_block} to carrot plant
					remove 1 carrot from {_player}
			if {_block_name} is "ripe beetroot plant":
				if {_player} has beetroot seed:
					set block at {_block} to beetroot plant
					remove 1 beetroot seed from {_player}







on place:
	if "%region at event-block%" contains "dungeon":
		if player doesn't have permission "worldguard.bypass":
			cancel event
		if player's gamemode is not creative:
			cancel event

	if name of player's tool is name of {item::forge_block}:
		wait 1 tick
		PlaceCustomBlock(player, location of block, "forge_block")
	if name of player's tool is name of {item::artifact_workshop}:
		wait 1 tick
		PlaceCustomBlock(player, location of block, "artifact_workshop")

	set metadata value "last_placed_block" of player to block


	if name of player's tool is "&6Respawnable Block":
		if player has permission "dungeons.admin":
			set {_loc} to location of event-block

			set {_floor} to GetLocationFloor(location of event-block)
			set {_x} to x coordinate of {_loc}
			set {_y} to y coordinate of {_loc}
			set {_z} to z coordinate of {_loc}

			load yaml "unlimited_adventures/Dungeons/FloorData/respawnable_blocks.yml" as "respawnable_blocks"
			
			set {_nr} to 0
			loop yaml node keys "%{_floor}%" from "respawnable_blocks":
				add 1 to {_nr}
			add 1 to {_nr}

			set yaml value "%{_floor}%.%{_nr}%.loc" from "respawnable_blocks" to "%{_x}%, %{_y}%, %{_z}%"
			set yaml value "%{_floor}%.%{_nr}%.type" from "respawnable_blocks" to "%type of event-block%"
			set {dungeons::respawnable_blocks::%{_floor}%::loc::%{_nr}%} to {_loc}
			set {dungeons::respawnable_blocks::%{_floor}%::type::%{_nr}%} to "%type of event-block%"

			save yaml "respawnable_blocks"

			send "&f[{@prefix}&f] &7Block placed!" to player

on break:
	if player can build at location of event-block:
		if {sculk_portal::loc::*} contains location of event-block:
			SculkPortalRemove(location of event-block)

	set {_nbt} to custom nbt of block
	if string tag "block_type" of {_nbt} is "forge_block" or "artifact_workshop":
		RemoveCustomBlock(player, block)


	if player doesn't have permission "worldguard.bypass":
		set {_type} to type of event-block
		if "%region at event-block%" contains "dungeon":
			set {_loc} to location of event-block
			set {_floor} to GetLocationFloor({_loc})
			if {dungeons::respawnable_blocks::%{_floor}%::loc::*} contains {_loc}:
				set {_block} to block at location(0, 0, 0, world "dungeons")
				loop 1000 times:
					if metadata value "block_%loop-number%" of {_block} is not set:
						set metadata value "date_%loop-number%" of {_block} to now
						set metadata value "block_%loop-number%" of {_block} to {_type}
						set metadata value "loc_%loop-number%" of {_block} to location of event-block
						set {_can_break} to true
						exit loop
			else:
				set {_loc} to location of event-block
				set {_floor} to GetLocationFloor({_loc})
				loop size of {dungeons::respawnable_blocks::%{_floor}%::loc::*} times:
					set {_nr} to loop-number
					if {dungeons::respawnable_blocks::%{_floor}%::loc::%{_nr}%} is location of event-block:
						set {_respawnable_block} to true
						set {_block} to block at location(0, 0, 0, world "dungeons")
						loop 1000 times:
							if metadata value "block_%loop-number-2%" of {_block} is not set:
								set metadata value "date_%loop-number-2%" of {_block} to now
								set metadata value "block_%loop-number-2%" of {_block} to {_type}
								set metadata value "loc_%loop-number-2%" of {_block} to location of event-block
								set {_can_break} to true
								exit loop
				if {_respawnable_block} is not true:

					if event-block is an ore:

						set {_block} to block at location(0, 0, 0, world "dungeons")
						loop 1000 times:
							if metadata value "block_%loop-number-2%" of {_block} is not set:
								set metadata value "date_%loop-number-2%" of {_block} to now
								set metadata value "block_%loop-number-2%" of {_block} to {_type}
								set metadata value "loc_%loop-number-2%" of {_block} to location of event-block
								set {_can_break} to true
								exit loop

			if {_can_break} is not true:
				cancel event
				stop
