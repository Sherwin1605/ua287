on load:
	ForgeReload()
	ForgeItemsReload()

	#	Custom Craftings

	register shaped recipe:
		id: "custom:forge_block"
#		result: anvil named name of {item::forge_block} with lore lore of {item::forge_block}#"&aThe Forge"
		result: {item::forge_block}
		shape: "ggg", "gag", "ggg"
		category: "custom"
		ingredients:
			set ingredient of "g" to gold ingot
			set ingredient of "a" to anvil


	register shaped recipe:
		id: "custom:emerald_sword"
#		result: diamond sword named "&rEmerald Sword" with custom model data 731
		result: {item::emerald_sword}
		shape: " e ", " e ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to emerald
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:emerald_pickaxe"
#		result: diamond pickaxe named "&rEmerald Pickaxe" with custom model data 731
		result: {item::emerald_pickaxe}
		shape: "eee", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to emerald
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:emerald_axe"
#		result: diamond axe named "&rEmerald Axe" with custom model data 731
		result: {item::emerald_axe}
		shape: "ee ", "es ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to emerald
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:emerald_shovel"
#		result: diamond shovel named "&rEmerald Pickaxe" with custom model data 731
		result: {item::emerald_shovel}
		shape: " e ", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to emerald
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:emerald_hoe"
#		result: diamond hoe named "&rEmerald Hoe" with custom model data 731
		result: {item::emerald_hoe}
		shape: "ee ", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to emerald
			set ingredient of "s" to stick



	register shaped recipe:
		id: "custom:copper_sword"
#		result: iron sword named "&rCopper Sword" with custom model data 732
		result: {item::copper_sword}
		shape: " e ", " e ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to copper ingot
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:copper_pickaxe"
#		result: iron pickaxe named "&rCopper Pickaxe" with custom model data 732
		result: {item::copper_pickaxe}
		shape: "eee", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to copper ingot
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:copper_axe"
#		result: iron axe named "&rCopper Axe" with custom model data 732
		result: {item::copper_axe}
		shape: "ee ", "es ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to copper ingot
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:copper_shovel"
#		result: iron shovel named "&rCopper Pickaxe" with custom model data 732
		result: {item::copper_shovel}
		shape: " e ", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to copper ingot
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:copper_hoe"
#		result: iron hoe named "&rCopper Hoe" with custom model data 732
		result: {item::copper_hoe}
		shape: "ee ", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to copper ingot
			set ingredient of "s" to stick



	register shaped recipe:
		id: "custom:amethyst_sword"
#		result: diamond sword named "&rAmethyst Sword" with custom model data 733
		result: {item::amethyst_sword}
		shape: " e ", " e ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to amethyst shard
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:amethyst_pickaxe"
#		result: diamond pickaxe named "&rAmethyst Pickaxe" with custom model data 733
		result: {item::amethyst_pickaxe}
		shape: "eee", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to amethyst shard
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:amethyst_axe"
#		result: diamond axe named "&rAmethyst Axe" with custom model data 733
		result: {item::amethyst_axe}
		shape: "ee ", "es ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to amethyst shard
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:amethyst_shovel"
#		result: diamond shovel named "&rAmethyst Pickaxe" with custom model data 733
		result: {item::amethyst_shovel}
		shape: " e ", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to amethyst shard
			set ingredient of "s" to stick
	register shaped recipe:
		id: "custom:amethyst_hoe"
#		result: diamond hoe named "&rAmethyst Hoe" with custom model data 733
		result: {item::amethyst_hoe}
		shape: "ee ", " s ", " s "
		category: "custom"
		ingredients:
			set ingredient of "e" to amethyst shard
			set ingredient of "s" to stick


expression %item% with skull value %string%:
	get:
		set {_item} to expr-1
		set {_nbt} to "{""minecraft:profile"":{id:[I;1012646827,1820739582,-1120930980,-1600539797],name:"""",properties:[{name:""textures"",value:""%expr-2%""}]}}"
		set {_item} to {_item} with nbt compound of {_nbt}
		return {_item}








function GenerateBackpack(type: string) :: item:
	if {forge::item::%{_type}%::rows} is set:
		set {_item} to {item::%{_type}%}
		set {_nbt} to custom nbt of {_item}
		set int tag "item_id" of {_nbt} to random integer between -999999999 and 999999999
		set string tag "item_type" of {_nbt} to {_type}
	return {_item}

function GenerateCatchingNet() :: item:
	set {_item} to {item::catching_net}
	set {_nbt} to custom nbt of {_item}
	set int tag "item_id" of {_nbt} to random integer between -999999999 and 999999999
	set string tag "item_type" of {_nbt} to "catching_net"
	return {_item}








function ForgeReload():
	load yaml "unlimited_adventures/CustomItems/config.yml" as "config"
	load yaml "unlimited_adventures/CustomItems/recipes.yml" as "recipes"
	load yaml "unlimited_adventures/CustomItems/items.yml" as "items"
	load yaml "unlimited_adventures/CustomItems/drops.yml" as "drops"

	if yaml value "version" from "config" is not set:
		wait 1 tick
		ForgeCreateConfigFile()
	if yaml value "version" from "recipes" is not set:
		wait 1 tick
		ForgeCreateRecipesFile()
		wait 3 tick
	if yaml value "version" from "drops" is not set:
		wait 1 tick
		ForgeCreateDropsFile()
		wait 0.5 second

#	wait 1 tick

	#	Forge Config
	if yaml value "require_unlocking" from "config" is set:
		set {forge::config::require_unlocking} to yaml value "require_unlocking" from "config"

	#	Recipes
	loop yaml node keys "recipes" from "recipes":
		set {forge::recipe::%loop-value%::*} to yaml list "recipes.%loop-value%" from "recipes"




	#	Drops Config

	clear {forge::drops::*}

	#	Global
	clear {forge::global::mobs::*}
	loop yaml node keys "global" from "drops":
		set {_mob} to loop-value
		add {_mob} to {forge::global::mobs::*}
		loop yaml node keys "global.%{_mob}%" from "drops":
			set {_item} to loop-value-2
			set {forge::drops::global::%{_mob}%::%{_item}%} to yaml value "global.%{_mob}%.%{_item}%" from "drops"



	#	Items Config
	clear {forge::items_list::*}
	clear {forge::backpacks_list::*}
	clear {forge::accessories_list::*}
	set {_stats::*} to "strength" and "health" and "regeneration" and "luck" and "wisdom" and "toughness" and "speed" and "fuel" and "night_vision" and "haste" and "oxygen"
	loop yaml node keys "items" from "items":
		add 1 to {_nr}
		add loop-value to {forge::items_list::*}
		if yaml value "items.%loop-value%.accessory" from "items" is set:
			add loop-value to {forge::accessories_list::*}

		if yaml value "items.%loop-value%.item" from "items" is set:
			set {forge::item::%loop-value%::item} to yaml value "items.%loop-value%.item" from "items" parsed as item
		if yaml value "items.%loop-value%.name" from "items" is set:
			set {forge::item::%loop-value%::name} to yaml value "items.%loop-value%.name" from "items"
		if yaml value "items.%loop-value%.custom_model_data" from "items" is set:
			set {forge::item::%loop-value%::custom_model_data} to yaml value "items.%loop-value%.custom_model_data" from "items"
		if yaml value "items.%loop-value%.model_custom_model_data" from "items" is set:
			set {forge::item::%loop-value%::model_custom_model_data} to yaml value "items.%loop-value%.model_custom_model_data" from "items"
		if yaml value "items.%loop-value%.backtools_model" from "items" is set:
			set {forge::item::%loop-value%::backtools_model} to yaml value "items.%loop-value%.backtools_model" from "items"
		if yaml value "items.%loop-value%.rows" from "items" is set:
			set {forge::item::%loop-value%::rows} to yaml value "items.%loop-value%.rows" from "items"
			add loop-value to {forge::backpacks_list::*}
		if yaml value "items.%loop-value%.attack_damage" from "items" is set:
			set {forge::item::%loop-value%::attack_damage} to yaml value "items.%loop-value%.attack_damage" from "items"
		if yaml value "items.%loop-value%.attack_speed" from "items" is set:
			set {forge::item::%loop-value%::attack_speed} to yaml value "items.%loop-value%.attack_speed" from "items"
		if yaml value "items.%loop-value%.armor" from "items" is set:
			set {forge::item::%loop-value%::armor} to yaml value "items.%loop-value%.armor" from "items"
		if yaml value "items.%loop-value%.armor_toughness" from "items" is set:
			set {forge::item::%loop-value%::armor_toughness} to yaml value "items.%loop-value%.armor_toughness" from "items"
		if yaml value "items.%loop-value%.knockback_resistance" from "items" is set:
			set {forge::item::%loop-value%::knockback_resistance} to yaml value "items.%loop-value%.knockback_resistance" from "items"
		if yaml value "items.%loop-value%.unbreakable" from "items" is set:
			set {forge::item::%loop-value%::unbreakable} to yaml value "items.%loop-value%.unbreakable" from "items"
		if yaml value "items.%loop-value%.skull" from "items" is set:
			set {forge::item::%loop-value%::skull} to yaml value "items.%loop-value%.skull" from "items"
#		if yaml value "items.%loop-value%.item_id" from "items" is set:
#			set {forge::item::%loop-value%::item_id} to yaml value "items.%loop-value%.item_id" from "items"
		if yaml list "items.%loop-value%.lore" from "items" is set:
			set {forge::item::%loop-value%::lore::*} to yaml list "items.%loop-value%.lore" from "items"

		#	Accessories
		loop {_stats::*}:
			if yaml value "items.%loop-value-1%.%loop-value-2%" from "items" is set:
				set {forge::item::%loop-value-1%::%loop-value-2%} to yaml value "items.%loop-value-1%.%loop-value-2%" from "items"
			else:
				if {forge::item::%loop-value-1%::%loop-value-2%} is set:
					delete {forge::item::%loop-value-1%::%loop-value-2%}

		if mod({_nr}, 3) is 0:
			wait 1 tick

	save yaml "config"
	save yaml "recipes"
	save yaml "items"
	save yaml "drops"


function ForgeItemsReload():
	#	Forge Items (Backpacks, Accessories, Weapons, Tools, etc.)
	loop 20 times:
		wait 0.5 second
		if {forge::items_list::*} is not set:
			wait 2 second
			continue

	delete {item::*}
	set {_item_nr} to 0
	loop {forge::items_list::*}:
		add 1 to {_item_nr}
		set {_flags} to false
		set {_item} to loop-value

		if {forge::item::%{_item}%::item} is set:
		
			#	Item
			set {item::%{_item}%} to {forge::item::%{_item}%::item}
			if {forge::item::%{_item}%::skull} is set:
				set {item::%{_item}%} to player head with skull value {forge::item::%{_item}%::skull}
			#	Name
			if {forge::item::%{_item}%::name} is set:
				set name of {item::%{_item}%} to {forge::item::%{_item}%::name}
			#	Custom Model Data
			if {forge::item::%{_item}%::custom_model_data} is set:
				set custom model data of {item::%{_item}%} to {forge::item::%{_item}%::custom_model_data}
			#	Armor value (armor & toughness)
			if {_item} contains "helmet":
				set {_part} to "head"
			if {_item} contains "chestplate":
				set {_part} to "chest"
			if {_item} contains "leggings":
				set {_part} to "legs"
			if {_item} contains "boots":
				set {_part} to "feet"
			if {_item} contains "sword" or "axe":
				set {_part} to "mainhand"
			if {forge::item::%{_item}%::attack_damage} is set:
#				RemoveItemAttribute({item::%{_item}%}, "generic.attack_damage")
				set {item::%{_item}%} to AddItemAttribute({item::%{_item}%}, "generic.attack_damage", {forge::item::%{_item}%::attack_damage}, "add_value", {_part})
#				send "attack_damage" to console
				set {_flags} to true
			if {forge::item::%{_item}%::attack_speed} is set:
#				RemoveItemAttribute({item::%{_item}%}, "generic.attack_speed")
				set {item::%{_item}%} to AddItemAttribute({item::%{_item}%}, "generic.attack_speed", {forge::item::%{_item}%::attack_speed}, "add_value", {_part})
#				send "attack_speed" to console
				set {_flags} to true
			if {forge::item::%{_item}%::armor} is set:
#				RemoveItemAttribute({item::%{_item}%}, "generic.armor")
				set {item::%{_item}%} to AddItemAttribute({item::%{_item}%}, "generic.armor", {forge::item::%{_item}%::armor}, "add_value", {_part})
#				send "armor" to console
			if {forge::item::%{_item}%::armor_toughness} is set:
				set {item::%{_item}%} to AddItemAttribute({item::%{_item}%}, "generic.armor_toughness", {forge::item::%{_item}%::armor_toughness}, "add_value", {_part})
			if {forge::item::%{_item}%::knockback_resistance} is set:
				set {item::%{_item}%} to AddItemAttribute({item::%{_item}%}, "generic.knockback_resistance", {forge::item::%{_item}%::knockback_resistance}, "add_value", {_part})
			if {forge::item::%{_item}%::unbreakable} is true:
				set {item::%{_item}%} to unbreakable {item::%{_item}%}
			if {forge::item::%{_item}%::item_id} is set:
				set {_n} to custom nbt of {item::%{_item}%}
				set string tag "item_type" of {_n} to {forge::item::%{_item}%::item_id}
			else:
				set {_n} to custom nbt of {item::%{_item}%}
				set string tag "item_type" of {_n} to {_item}

			if {_flags} is true:
#				add attributes flag to hidden item flags of {item::%{_item}%}
				add hide attributes to item flags of {item::%{_item}%}

			#	Lore
			set {_nr} to 0
			loop {forge::item::%loop-value%::lore::*}:
				add 1 to {_nr}
				set line {_nr} of lore of {item::%{_item}%} to colored loop-value-2


		if mod({_item_nr}, 5) is 0:
			wait 1 tick













function ForgeCreateConfigFile():
	load yaml "unlimited_adventures/CustomItems/config.yml" as "config"

	set yaml value "version" from "config" to 1
	set the comments of yaml node "version" from "config" to "Please DO NOT change version number!"

	set yaml list "require_unlocking" from "config" to false

	set the comments of yaml node "require_unlocking" from "config" to "Set to true if items should require unlocking before they can be forged."
	save yaml "config"



function ForgeCreateRecipesFile():
	load yaml "unlimited_adventures/CustomItems/recipes.yml" as "recipes"

	set yaml value "version" from "recipes" to 1
	set the comments of yaml node "version" from "recipes" to "Please DO NOT change version number!"


	#	Items

	set yaml list "recipes.dynamite" from "recipes" to "1 of tnt" and "3 of string" and "3 of iron ingot"
	set yaml list "recipes.catching_net" from "recipes" to "5 of string" and "3 of slimeball"
	set yaml list "recipes.elytra" from "recipes" to "10 of custom:dragonscale" and "32 of phantom membrane"
	set yaml list "recipes.dragonscale_sword" from "recipes" to "2 of custom:dragonscale" and "netherite sword"
	set yaml list "recipes.dragonscale_axe" from "recipes" to "3 of custom:dragonscale" and "netherite axe"
	set yaml list "recipes.dragonscale_helmet" from "recipes" to "5 of custom:dragonscale" and "netherite helmet"
	set yaml list "recipes.dragonscale_chestplate" from "recipes" to "8 of custom:dragonscale" and "netherite chestplate"
	set yaml list "recipes.dragonscale_leggings" from "recipes" to "7 of custom:dragonscale" and "netherite leggings"
	set yaml list "recipes.dragonscale_boots" from "recipes" to "4 of custom:dragonscale" and "netherite boots"

	set yaml list "recipes.random_teleportation_scroll" from "recipes" to "paper" and "2 of lapis lazuli"
	set yaml list "recipes.home_teleportation_scroll" from "recipes" to "paper" and "2 of lapis lazuli" and "2 of gold ingot"
	set yaml list "recipes.portal_stone" from "recipes" to "echo shard" and "4 of amethyst shard" and "4 of ender eye"


	#	Backpacks
	set yaml list "recipes.traveler_backpack" from "recipes" to "10 of leather" and "2 of iron ingots"
	set yaml list "recipes.adventure_backpack" from "recipes" to "custom:traveler_backpack" and "5 of iron ingots" and "10 of string"
	set yaml list "recipes.hero_backpack" from "recipes" to "custom:adventure_backpack" and "2 of diamond" and "5 of gold ingots"

	set yaml list "recipes.bone_sword" from "recipes" to "10 of skeleton skull"
	set yaml list "recipes.crocodile_sword" from "recipes" to "10 of custom:crocodile_tooth"
	set yaml list "recipes.siege_crossbow" from "recipes" to "crossbow" and "5 of diamond" and "20 of iron ingot"


	#	Accessories
	set yaml list "recipes.wool_scarf" from "recipes" to "10 of white wool" and "10 of red wool" and "10 of strings"
	set yaml list "recipes.lightning_boots" from "recipes" to "custom:hermes_boots" and "custom:rocket_boots"
	set yaml list "recipes.miner_helmet_lamp" from "recipes" to "custom:miner_helmet" and "custom:flashlight"
	set yaml list "recipes.talisman_of_vitality" from "recipes" to "custom:philosopher_stone" and "custom:silver_chain"
	set yaml list "recipes.crystal_amulet" from "recipes" to "custom:green_crystal" and "custom:pink_crystal" and "custom:blue_crystal" and "custom:yellow_crystal"




	set the comments of yaml node "recipes" from "recipes" to " " and "Forge Items crafting recipes:" and " "
	save yaml "recipes"



function ForgeCreateDropsFile():
	load yaml "unlimited_adventures/CustomItems/drops.yml" as "drops"

	set yaml value "version" from "drops" to 1
	set the comments of yaml node "version" from "drops" to "Please DO NOT change version number!"


	set yaml value "global.goblin.custom:blue_crystal" from "drops" to 2
	set yaml value "global.goblin.custom:yellow_crystal" from "drops" to 2
	set yaml value "global.goblin.custom:pink_crystal" from "drops" to 2
	set yaml value "global.goblin.custom:green_crystal" from "drops" to 2
	set yaml value "global.crocodile.custom:crocodile_tooth" from "drops" to 5
	set yaml value "global.zombie.custom:zombie_brain" from "drops" to 1
	set yaml value "global.zombie.custom:shackle" from "drops" to 0.4
	set yaml value "global.skeleton.custom:bone_necklace" from "drops" to 0.4
	set yaml value "global.skeleton.skeleton_skull" from "drops" to 1
	set yaml value "global.spider.custom:ninja_cloak" from "drops" to 0.5
	set yaml value "global.spider.custom:spider_venom" from "drops" to 1
	set yaml value "global.creeper.custom:rocket_boots" from "drops" to 0.5
	set yaml value "global.enderman.custom:hermes_boots" from "drops" to 0.6
	set yaml value "global.stray.custom:shiver_bracelet" from "drops" to 0.5
	set yaml value "global.husk.custom:magic_bracelet" from "drops" to 0.5
	set yaml value "global.witch.custom:vitality_ring" from "drops" to 1.5
	set yaml value "global.witch.custom:speed_ring" from "drops" to 1.5
	set yaml value "global.piglin.custom:gold_tooth" from "drops" to 1
	set yaml value "global.piglin.custom:gold_pouch" from "drops" to 0.5
	set yaml value "global.piglin_brute.custom:gold_tooth" from "drops" to 2
	set yaml value "global.piglin_brute.custom:gold_pouch" from "drops" to 1
	set yaml value "global.wither_skeleton.custom:dark_magic_necklace" from "drops" to 1
	set yaml value "global.blaze.custom:philosopher_stone" from "drops" to 0.75
	set yaml value "global.ghast.custom:silver_chain" from "drops" to 1
	set yaml value "global.strider.custom:magma_boots" from "drops" to 1
	set yaml value "global.magma_cube.custom:molten_dice" from "drops" to 0.5
	set yaml value "global.drowned.custom:diving_mask" from "drops" to 1
	set yaml value "global.guardian.custom:diving_mask" from "drops" to 5
	set yaml value "global.elder_guardian.custom:diving_mask" from "drops" to 50
	set yaml value "global.ravager.custom:horseshoe" from "drops" to 3
	set yaml value "global.warden.custom:sculk_shield" from "drops" to 5
	set yaml value "global.warden.custom:echo_shard" from "drops" to 20
	set yaml value "global.ender_dragon.custom:dragonscale" from "drops" to 500
	set yaml value "global.ender_dragon.custom:ender_gauntlet" from "drops" to 10
	set yaml value "global.wither.custom:wither_crown" from "drops" to 10


	set the comments of yaml node "global" from "drops" to " " and "You can modify percentage chances for various item drops from mobs" and "You can add your own drops, just follow the formatting!" and " "

	save yaml "drops"




#function GetIngredientItem(item: string) :: item:
#	set {_nr} to -1
#	loop 10 times:
#		add 1 to {_nr}
#		replace all "%{_nr}%" in {_item} with ""
#	replace all " of " in {_item} with ""
#	set {_item} to GetItem({_item})
#	return {_item}






function GetRandomPlayer() :: player:
	return random element out of all players

function PlayerHasItem(player: player, ingredient: string) :: boolean:
	set {_boolean} to false

	set {_amount} to GetIngredientAmount({_ingredient})
	set {_item} to GetIngredientItem({_ingredient})

#	send "&b%{_amount}% &fof &a%{_item}%" to {_player}
	loop all items in {_player}'s inventory:
		if "%type of loop-item%" is "%type of {_item}%":
			if "%custom model data of loop-item%" is "%custom model data of {_item}%":
				if item amount of loop-item >= {_amount}:
					set {_boolean} to true
	return {_boolean}









command /forge [<player>] [<text>]:
	permission: admin
	trigger:
		set {_player} to player-arg

		if difference between metadata value "crafting_delay" of {_player} and now < 1 second:
			stop
		set metadata value "crafting_delay" of {_player} to now


		#	Loops through all recipes to then compare them to command argument
		loop {forge::items_list::*}:
			set {_crafted_item} to loop-value-1
			
			if arg 2 is {_crafted_item}:

				#	Stops the code if player doesn't have all ingredients
				if ForgeCanCraft({_player}, {_crafted_item}) is not true:
					send "&f &cInsufficient ingredients!" to {_player}
					stop

				#	Stops the code if player doesn't have space for product
				if {_player} doesn't have space for {item::%{_crafted_item}%}:
					send "&f &cYou don't have space for more items!" to {_player}
					stop

				#	Takes needed ingredients from the player

				loop all items in {_player}'s inventory:
					add loop-item to {_player_items::*}

				loop {forge::recipe::%{_crafted_item}%::*}:
					set {_ingredient} to loop-value-2
					set {_amount} to GetIngredientAmount({_ingredient})
					set {_item} to GetIngredientItem({_ingredient})
#					set {_ingredient_item_type} to {_ingredient}
#					replace all "custom:" with "" in {_ingredient_item_type}

					loop {_player_items::*}:
						set {_type_correct} to false
						set {_p_item} to loop-value-3
						if "%type of {_p_item}%" is "%type of {_item}%":
							if GetCustomItemId(GetItem({_ingredient})) is set:
								if GetCustomItemId({_p_item}) is GetCustomItemId(GetItem({_ingredient})):
									set {_type_correct} to true
							else:
								set {_type_correct} to true
						if {_type_correct} is true:
							if item amount of {_p_item} >= {_amount}:
								set {_n} to custom nbt of {_p_item}
								if compound list tag "items" of {_n} is set:
									set {_bp_items::*} to compound list tag "items" of {_n}
								remove {_amount} of {_p_item} from {_player}
								exit loop

				#	Gives player the crafting product

				if {forge::item::%{_crafted_item}%::rows} is set:
					set {_crafted_item} to GenerateBackpack({_crafted_item})
				else:
					set {_crafted_item} to {item::%{_crafted_item}%}
				if {_bp_items::*} is set:
					set {_n} to custom nbt of {_crafted_item}
					set compound list tag "items" of {_n} to {_bp_items::*}
				if {_player} has space for {_crafted_item}:
					give {_crafted_item} to {_player}
				else:
					drop {_crafted_item} at {_player}
					send "&f &fYou don't have space for more items!" to {_player}
				play sound "custom.forge_craft" with volume 0.45 and pitch 1 at {_player}
				ForgeUpdateCraftableItems({_player})



function ForgeCanCraft(player: player, item: string) :: boolean:
	set {_player_items::*} to all items in inventory of {_player}

	clear {_ingredients::*}
	loop {forge::recipe::%{_item}%::*}:
		add GetIngredientItem(loop-value) to {_ingredients::*}
		set {_amount::%GetIngredientItem(loop-value)%} to GetIngredientAmount(loop-value)


	loop {_ingredients::*}:
		set {_ingredient} to loop-value
		set {_amount} to {_amount::%{_ingredient}%}

		#	Checking regular & custom items
		if {_player} has {_amount} of loop-value:
			remove loop-value from {_ingredients::*}
		else:
			#	Checking items with nbt
			loop {_player_items::*}:
				set {_p_item} to loop-value-2
				if GetCustomItemId({_p_item}) is GetCustomItemId({_ingredient}):
					if {_player} has {_amount} of {_p_item}:
						remove {_ingredient} from {_ingredients::*}

	if size of {_ingredients::*} is 0:
		return true


function GetIngredientItem(item: string) :: item:
	if {_item} contains "custom:":
		replace all "custom:" with "" in {_item}
		set {_ingredient::*} to {_item} split at " "
		return {item::%last element out of {_ingredient::*}%}
	else:
		if {_item} contains " of ":
			set {_ingredient::*} to {_item} split at " "
			remove first element out of {_ingredient::*} from {_ingredient::*}
			remove first element out of {_ingredient::*} from {_ingredient::*}
			set {_item} to join {_ingredient::*} by " " 

		return {_item} parsed as item

function GetIngredientAmount(item: string) :: integer:
	set {_amount} to 1
	if {_item} contains " of ":
		set {_item::*} to {_item} split at " "
		set {_amount} to first element out of {_item::*} parsed as integer
	return {_amount}

function GetCustomItemId(item: item) :: string:
	set {_nbt} to custom nbt of {_item}
	set {_type} to string tag "item_type" of {_nbt}
	return {_type}
#	return string tag "item_type" of custom nbt of {_item}


function ForgeUpdateCraftableItems(player: player):
	if difference between metadata value "forge_updatecraftableitems_cooldown" of {_player} and now < 0.3 second:
		stop
	set metadata value "forge_updatecraftableitems_cooldown" of {_player} to now
	
#	loop all items in {_player}'s inventory:
#		add loop-item to {_player_items::*}
	
	load yaml "unlimited_adventures/CustomItems/recipes.yml" as "recipes"
	loop yaml node keys "recipes" from "recipes":
		add loop-value to {_list_of_craftable_items::*}
	save yaml "recipes"
	wait 1 tick

	loop {_list_of_craftable_items::*}:
		set {_item} to loop-value
		add 1 to {_loop_nr}
		loop {forge::recipe::%{_item}%::*}:
			
			set {_ingredient} to loop-value-2
			set {_amount} to GetIngredientAmount({_ingredient})
			set {_item_type} to GetIngredientItem({_ingredient})

			set {_boolean} to false

			if {_player}'s inventory contains {_amount} of {_item_type} with custom model data {_item_type}:
				set {_boolean} to true
			else:
				#exit loop

				loop {_player}'s inventory:
					if name of {_item_type} is name of loop-value-3:
						if custom model data of {_item_type} is custom model data of loop-value-3:
							set {_boolean2} to true
							exit loop
						else:
							set {_boolean2} to false
					else:
						set {_boolean2} to false
				if {_boolean2} is true:
					#send "&bFound %{_amount} of {_item_type} with custom model data {_item_type}%!" to all players
					set {_boolean} to true
				else:
					#send "&cDidn't find %{_amount} of {_item_type} with custom model data {_item_type}%!" to all players
					exit loop

		if {_boolean} is true:
			add {_item} to {_items_player_can_craft::*}
		if mod({_loop_nr}, 8) is 0:
			wait 1 tick

	set metadata value "forge_craftable_items" of {_player} to "%{_items_player_can_craft::*}%"





function IsForgeIngredient(item: string) :: boolean:
	loop {forge::items_list::*}:
		if {_item} is loop-value:
			return true
			stop
	return false


command /forgeupdatecraftableitems [<player>]:
	permission: admin
	trigger:
		ForgeUpdateCraftableItems(player-arg)








function MobForgeDrops(victim: entity):
	set {_loc} to location of {_victim}
	set {_nbt} to nbt compound of {_victim}
	if "%{_nbt}%" contains "mythicmobs:type"":""Bear""":
		set {_victim} to "bear"
	if "%{_nbt}%" contains "mythicmobs:type"":""Goblin""":
		set {_victim} to "goblin"
	if "%{_nbt}%" contains "mythicmobs:type"":""Buffaloo""":
		set {_victim} to "buffaloo"
	if "%{_nbt}%" contains "mythicmobs:type"":""Crocodile""":
		set {_victim} to "crocodile"

	
	set {_victim_name} to "%{_victim}%"
	replace all " " with "_" in {_victim_name}


	if {forge::global::mobs::*} contains {_victim_name}:
		loop {forge::drops::global::%{_victim_name}%::*}:
			set {_chance} to loop-value
			if difference between {booster::luck::date} and now < {booster::luck::duration}:
				set {_chance} to {_chance}*2
#				send "chance: %{_chance}%  item: %loop-index%" to all players
			if {_chance} <= 100:
#				send "%loop-index% %loop-value% %GetItem(loop-index)%" to all players
				chance of {_chance}%:
					drop 1 of GetItem(loop-index) at {_loc}
			else:
#				send "2: %loop-index% %loop-value% %GetItem(loop-index)%" to all players
				set {_amount} to round({_chance}/100)
				if {_victim} is a ender dragon:
					wait 15 seconds
					drop {_amount} of GetItem(loop-index) at {_loc}
				else:
					drop {_amount} of GetItem(loop-index) at {_loc}













command /customitemsreload:
	aliases: forgereload
	permission: admin
	trigger:
		ForgeReload()
		wait 3 seconds
		send "&f &fConfig of Custom Items has been reloaded!" to sender




command /forgeunlock [<player>] [<text>]:
	aliases: unlockforge
	permission: admin
	trigger:
		loop {forge::items_list::*}:
			if arg-2 is loop-value:
				set {forge::recipe::%loop-value%::unlocked::%uuid of player-arg%} to true
				exit loop


on tab complete of "/forgeunlock":
	set {_list::*} to {forge::items_list::*}
	loop {forge::items_list::*}:
		if {forge::recipe::%loop-value%::unlocked::%uuid of player%} is true:
			remove loop-value from {_list::*}
	set tab completions for position 2 to {_list::*}





on right click:
	if event-block is anvil or smithing table:
		set {_nbt} to custom nbt of block
		if string tag "block_type" of {_nbt} is "forge_block":
			cancel event
			UseSpecialBlock(player, block, "forge_block")
		if string tag "block_type" of {_nbt} is "artifact_workshop":
			cancel event
			UseSpecialBlock(player, block, "artifact_workshop")
	if GetCustomItemId(player's tool) is "catching_net":
		cancel event
		UseCatchingNet(player)
	if GetCustomItemId(player's tool) is "dynamite":
		cancel event
		ThrowDynamite(player)



function UseCatchingNet(player: player):
	set {_target} to target entity of {_player}
	set {_block} to target block of {_player}
	if {_target} is a mob:
		if {_target} is not a monster:
			if distance between {_target} and {_player} > 5:
				stop
			if {_target} is ender dragon or iron golem or wither or warden or ghast or vindicator or armor stand:
				stop
			if metadata value "custom_mob" of {_target} is set:
				stop
#			if item amount of {_player}'s tool > 1:
#				stop

			set {_nbt} to custom nbt of {_player}'s tool
			set {_mob} to string tag "mob" of {_nbt}
			set {_mob_nbt} to full nbt of {_target}
			
#			set {_hp} to float tag "hp" of {_nbt}
			
			if {_mob} is not set:
				if difference between metadata value "catching_net_delay" of {_player} and now < 0.5 seconds:
					stop
				set metadata value "catching_net_delay" of {_player} to now
				play sound "entity.player.attack.sweep" with volume 0.3 and pitch 1.5 at location of {_target}
				play sound "entity.item.pickup" with volume 0.6 and pitch 1.5 at location of {_target}
				draw 6 poof at location 1 meter above {_block} with offset vector(0, 0, 0) with extra 0.3
				set string tag "mob" of {_nbt} to "%{_target}%"
				set float tag "hp" of {_nbt} to health of {_target}
				set string tag "mob_nbt" of {_nbt} to {_mob_nbt}
				teleport {_target} to location(x coordinate of {_target}, -100, z coordinate of {_target})
				set line 4 of lore of {_player}'s tool to "&fContains %capitalize(string tag "mob" of {_nbt})%"
				set damage value of {_player}'s tool to damage value of {_player}'s tool + 2
				stop
	if {_target} is not set:
		if {_block} is set:
			if distance between {_block} and {_player} > 5:
				stop
			set {_nbt} to custom nbt of {_player}'s tool
			set {_mob} to string tag "mob" of {_nbt}

			set {_hp} to float tag "hp" of {_nbt}
			
			set {_mob} to {_mob} parsed as entitytype
			
			if {_mob} is set:
				if difference between metadata value "catching_net_delay" of {_player} and now < 0.5 seconds:
					stop
				set metadata value "catching_net_delay" of {_player} to now
				play sound "entity.player.attack.sweep" with volume 0.2 and pitch 1.5 at {_block}
				play sound "entity.item.pickup" with volume 0.6 and pitch 1.5 at {_block}
				draw 3 poof at location 1 meter above {_block} with offset vector(0.2, 0.2, 0.2) with extra 0.01

#				set {_mob_nbt} to nbt compound from "{IsBaby:1}"
				set {_mob_nbt} to string tag "mob_nbt" of {_nbt}
				spawn {_mob} at location 0.5 meter above {_block}# with nbt {_mob_nbt}
				set health of last spawned mob to {_hp}
				delete string tag "mob" of {_nbt}
				delete float tag "hp" of {_nbt}
				set line 4 of lore of {_player}'s tool to "&fEmpty. Catch something!"
				set damage value of {_player}'s tool to damage value of {_player}'s tool + 2
#				damage {_player}'s tool by 2# + damage value of {_player}'s tool

	


function ThrowDynamite(player: player):
	if region at {_player} is "spawn" or "dungeons":
		stop
	if difference between metadata value "dynamite_delay" of {_player} and now < 1 seconds:
		stop
	set metadata value "dynamite_delay" of {_player} to now
	remove 1 of {item::dynamite} from {_player}
	set {_loc} to location 1.5 meter above {_player}
	
	set {_yaw} to random number between -180 and 180
	set yaw of {_loc} to {_yaw}
	spawn armor stand at {_loc} with nbt compound from "{Invisible:1b}"
	set {_stand} to last spawned armor stand
	set helmet of {_stand} to feather with custom model data 211
	set metadata value "alive" of {_stand} to true
	push {_stand} in direction of {_player} with speed 2

	set {_nbt} to nbt compound of {_stand}

	loop 60 times:
		draw 1 smoke at {_stand} with offset vector(0.1, 0.1, 0.1) with extra 0
		if {_stand} is not on ground:
			add 30 to {_yaw}
			set float list tag "Rotation" of {_nbt} to {_yaw} and 0
			set yaw of {_stand} to {_yaw}
		wait 1 tick
	play sound "minecraft:entity.generic.explode" with volume 2 and pitch 1.2 at location of {_stand}
	draw 2 explosion emitter at {_stand} with offset vector(1, 1, 1) with extra 0
	kill {_stand}
	set {_blocks::*} to barrier and light block and bedrock and command block and end gateway and end portal and end portal frame and structure block and ancient debris and anvil and block of netherite and crying obsidian and respawn anchor and reinforced deepslate and ender chest and lava and water and dragon egg
	if {_stand} is in water:
		stop
	loop all blocks in radius 5 of {_stand}:
		if {_player} can build at location of loop-block:
			if {_blocks::*} doesn't contain type of loop-block:
				if loop-block is grass or tall grass or any flower:
					set loop-block to air
				chance of 80%:
					set loop-block to air
	loop all blocks in radius 3 of {_stand}:
		if {_player} can build at location of loop-block:
			if {_blocks::*} doesn't contain type of loop-block:
				chance of 80%:
					set loop-block to air
	loop all entities in radius 5 of {_stand}:
		if loop-entity is a living entity:
			set {_distance} to distance between loop-entity and {_stand}
			if {_distance} < 1:
				set {_distance} to 1
			set {_distance} to (5/{_distance})/5
			damage loop-entity by 4*{_distance}



function PlaceCustomBlock(player: player, loc: location, block: string):
	if {_player} can build at location of {_loc}:
		if {_block} is "forge_block":
			set block at {_loc} to unbroken anvil
		if {_block} is "artifact_workshop":
			set block at {_loc} to smithing table
#		remove 1 of {item::%{_block}%} from {_player}
		set {_nbt} to custom nbt of block at {_loc}
		set string tag "block_type" of {_nbt} to {_block}

		

function RemoveCustomBlock(player: player, block: block):
	if {_player} can build at location of {_block}:
		set {_nbt} to custom nbt of {_block}
		if string tag "block_type" of {_nbt} is "forge_block":
			set block at location of {_block} to air
			drop 1 of {item::forge_block} at {_block}
		if string tag "block_type" of {_nbt} is "artifact_workshop":
			set block at location of {_block} to air
			drop 1 of {item::artifact_workshop} at {_block}



function UseSpecialBlock(player: player, block: block, type: string):
	if {_type} is "forge_block":
		if difference between metadata value "forge_block_click_cooldown" of {_player} and now < 1 second:
			stop
		set metadata value "forge_block_click_cooldown" of {_player} to now
		execute console command "cp forge %{_player}%"
		play sound "minecraft:custom.forge_open" with volume 0.5 and pitch 1 at {_block}
	if {_type} is "artifact_workshop":
		if difference between metadata value "artifact_workshop_click_cooldown" of {_player} and now < 1 second:
			stop
		set metadata value "artifact_workshop_click_cooldown" of {_player} to now
		OpenArtifactWorkshopMenu({_player})





command /customiteminfo:
	permission: admin
	trigger:
		send "Item's type: %GetCustomItemId(player's tool)%" to player